document.addEventListener('DOMContentLoaded', function() {
  // Application state
  let chatService = null;
  let currentProject = null;
  let currentChat = null;
  let chats = [];
  let uiRenderer = null;
  let isConnecting = false;
  let messageQueue = [];
  let sidebarCollapsed = false;
  let contextMenuChatId = null;
  
  // DOM elements
  const elements = {
      // Sidebar elements
      chatSidebar: document.getElementById('chatSidebar'),
      sidebarProjectName: document.getElementById('sidebarProjectName'),
      sidebarCollapseBtn: document.getElementById('sidebarCollapseBtn'),
      collapseIcon: document.getElementById('collapseIcon'),
      newChatBtn: document.getElementById('newChatBtn'),
      chatList: document.getElementById('chatList'),
      loadingChats: document.getElementById('loadingChats'),
      
      // Context Menu elements
      chatContextMenu: document.getElementById('chatContextMenu'),
      renameChatBtn: document.getElementById('renameChatBtn'),
      deleteChatBtn: document.getElementById('deleteChatBtn'),
      
      // Delete Modal elements
      deleteModalOverlay: document.getElementById('deleteModalOverlay'),
      deleteModalMessage: document.getElementById('deleteModalMessage'),
      cancelDeleteBtn: document.getElementById('cancelDeleteBtn'),
      confirmDeleteBtn: document.getElementById('confirmDeleteBtn'),
      
      // Chat elements
      chatContainer: document.getElementById('chatContainer'),
      chatTitle: document.getElementById('chatTitle'),
      chatSubtitle: document.getElementById('chatSubtitle'),
      userEmail: document.getElementById('userEmail'),
      creditsDisplay: document.getElementById('creditsDisplay'),
      connectionDot: document.getElementById('connectionDot'),
      connectionText: document.getElementById('connectionText'),
      chatBody: document.getElementById('chatBody'),
      messageInput: document.getElementById('messageInput'),
      sendMessageBtn: document.getElementById('sendMessageBtn'),
      welcomeMessage: document.getElementById('welcomeMessage'),
      backBtn: document.getElementById('backBtn'),
      connectionError: document.getElementById('connectionError'),
      reconnectBtn: document.getElementById('reconnectBtn'),
      connectedStatus: document.querySelector('.status-connected'),
      disconnectedStatus: document.querySelector('.status-disconnected'),
      reconnectingStatus: document.querySelector('.status-reconnecting')
  };
  
  /**
   * Initialize the enhanced chat application
   */
  async function initializeApp() {
      try {
          console.log('🚀 Starting WebSocket-only chat application...');
          
          // Initialize environment
          initializeEnvironment();
          
          // Check authentication
          if (!AuthService || !AuthService.init()) {
              redirectToLogin('Authentication service not available');
              return;
          }
          
          if (!AuthService.isAuthenticated()) {
              redirectToLogin('Not authenticated');
              return;
          }
          
          // Get project ID
          const projectId = getProjectId();
          if (!projectId) {
              redirectToProjects();
              return;
          }
          
          // Initialize UI
          await initializeUI();
          
          // Load project
          await loadProject(projectId);
          
          // Load chats for this project
          await loadProjectChats(projectId);
          
          // Initialize chat service
          await initializeChat();
          
          // Setup event listeners
          setupEventListeners();
          
          console.log('✅ WebSocket-only chat application initialized');
          
      } catch (error) {
          console.error('❌ Failed to initialize:', error);
          showError('Failed to initialize chat. Please refresh the page.');
      }
  }
  
  /**
   * Initialize environment
   */
  function initializeEnvironment() {
      // Ensure config exists
      if (!window.AAAI_CONFIG) {
          window.AAAI_CONFIG = {
              ENVIRONMENT: 'production',
              ENABLE_WEBSOCKETS: true,
              ENABLE_DEBUG: true
          };
      }
      
      // Show environment indicator
      const env = window.AAAI_CONFIG.ENVIRONMENT;
      if (env !== 'production') {
          const indicator = document.getElementById('envIndicator');
          const envText = document.getElementById('envText');
          if (indicator && envText) {
              indicator.className = `env-indicator ${env}`;
              envText.textContent = `${env.toUpperCase()} Environment`;
              document.body.classList.add('with-env-indicator');
          }
      }
  }
  
  /**
   * Initialize UI
   */
  async function initializeUI() {
      // Display user info
      const user = AuthService.getCurrentUser();
      if (user && elements.userEmail) {
          elements.userEmail.textContent = user.email;
      }
      
      // Load credits
      try {
          const credits = await AuthService.getUserCredits();
          if (elements.creditsDisplay) {
              elements.creditsDisplay.textContent = `Credits: ${credits}`;
          }
      } catch (error) {
          console.warn('Failed to load credits:', error);
          if (elements.creditsDisplay) {
              elements.creditsDisplay.textContent = 'Credits: --';
          }
      }
      
      // Initialize UI renderer
      if (typeof UIComponentRenderer !== 'undefined') {
          uiRenderer = UIComponentRenderer.init({
              linkHandler: (url) => window.open(url, '_blank'),
              actionHandler: (action, value) => {
                  if (action === 'reply' && value) {
                      elements.messageInput.value = value;
                      sendMessage();
                  }
              }
          });
      }
  }
  
  /**
   * Load project data
   */
  async function loadProject(projectId) {
      try {
          // Try to load from API
          const result = await AuthService.executeFunction('get_project_details', {
              project_id: projectId
          });
          
          if (result?.data?.success) {
              currentProject = result.data.project;
          }
      } catch (error) {
          console.warn('Failed to load project from API:', error);
      }
      
      // Use fallback if needed
      if (!currentProject) {
          currentProject = {
              id: projectId,
              name: 'AI Assistant Project',
              description: 'Intelligent conversation assistant'
          };
      }
      
      // Update UI
      if (elements.sidebarProjectName) {
          elements.sidebarProjectName.textContent = currentProject.name;
      }
      
      document.title = `${currentProject.name} - AAAI Solutions`;
  }
  
  /**
   * Load chats for the current project
   */
  async function loadProjectChats(projectId) {
      try {
          showChatListLoading(true);
          
          // Try to load from API - you'll need to implement this function
          // const result = await AuthService.executeFunction('list_project_chats', {
          //     project_id: projectId
          // });
          
          // Mock data for demonstration
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          chats = [
              {
                  id: 'chat_1',
                  name: 'Initial Conversation',
                  created_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
                  updated_at: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
                  message_count: 8,
                  last_message_preview: 'That sounds like a great approach...'
              },
              {
                  id: 'chat_2',
                  name: 'Feature Planning',
                  created_at: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                  updated_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
                  message_count: 15,
                  last_message_preview: 'Let me help you break this down...'
              },
              {
                  id: 'chat_3',
                  name: 'Technical Discussion',
                  created_at: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
                  updated_at: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                  message_count: 23,
                  last_message_preview: 'Here are some best practices...'
              }
          ];
          
          renderChatList();
          
          // Auto-select the first chat or create a new one
          const chatId = getChatIdFromURL();
          if (chatId && chats.find(c => c.id === chatId)) {
              selectChat(chatId);
          } else if (chats.length > 0) {
              selectChat(chats[0].id);
          } else {
              createNewChat();
          }
          
      } catch (error) {
          console.error('Failed to load chats:', error);
          showChatListError();
      } finally {
          showChatListLoading(false);
      }
  }
  
  /**
   * Render the chat list in the sidebar
   */
  function renderChatList() {
      if (chats.length === 0) {
          elements.chatList.innerHTML = `
              <div class="empty-chat-list">
                  <ion-icon name="chatbubbles-outline"></ion-icon>
                  <p>No chats yet.<br>Create your first chat!</p>
              </div>
          `;
          return;
      }
      
      elements.chatList.innerHTML = chats.map(chat => `
          <button class="chat-item" data-chat-id="${chat.id}" onclick="selectChat('${chat.id}')">
              <ion-icon name="chatbubble-outline" class="chat-item-icon"></ion-icon>
              <div class="chat-item-content">
                  <div class="chat-item-name">${escapeHtml(chat.name)}</div>
                  <div class="chat-item-preview">${escapeHtml(chat.last_message_preview || 'No messages yet')}</div>
              </div>
              <button class="chat-item-menu" onclick="event.stopPropagation(); showChatMenu('${chat.id}', event)">
                  <ion-icon name="ellipsis-horizontal-outline"></ion-icon>
              </button>
          </button>
      `).join('');
  }
  
  /**
   * Select and switch to a specific chat
   */
  async function selectChat(chatId) {
      try {
          const chat = chats.find(c => c.id === chatId);
          if (!chat) {
              console.error('Chat not found:', chatId);
              return;
          }
          
          // Update current chat
          currentChat = chat;
          
          // Update URL without page reload
          const url = new URL(window.location);
          url.searchParams.set('chat', chatId);
          window.history.replaceState({}, '', url);
          
          // Update UI
          updateChatHeader(chat);
          updateChatListSelection(chatId);
          
          // Clear current messages
          clearChatBody();
          
          // Load chat messages
          await loadChatMessages(chatId);
          
          console.log('✅ Selected chat:', chat.name);
          
      } catch (error) {
          console.error('Error selecting chat:', error);
          showError('Failed to load chat');
      }
  }
  
  /**
   * Create a new chat
   */
  async function createNewChat() {
      try {
          // Generate new chat
          const newChat = {
              id: `chat_${Date.now()}`,
              name: `Chat ${chats.length + 1}`,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
              message_count: 0,
              last_message_preview: null
          };
          
          // In a real app, you'd save this to the backend:
          // await AuthService.executeFunction('create_chat', {
          //     project_id: currentProject.id,
          //     name: newChat.name
          // });
          
          // Add to local list
          chats.unshift(newChat);
          
          // Re-render chat list
          renderChatList();
          
          // Select the new chat
          await selectChat(newChat.id);
          
          console.log('✅ Created new chat:', newChat.name);
          
      } catch (error) {
          console.error('Error creating new chat:', error);
          showError('Failed to create new chat');
      }
  }
  
  /**
   * Load messages for a specific chat
   */
  async function loadChatMessages(chatId) {
      try {
          // Show loading state
          showWelcomeMessage();
          
          // In a real app, load from backend:
          // const result = await AuthService.executeFunction('get_chat_messages', {
          //     chat_id: chatId
          // });
          
          // Mock messages for demonstration
          if (chatId !== chats[0]?.id || chats.find(c => c.id === chatId)?.message_count === 0) {
              // New chat or empty chat - show welcome
              showWelcomeMessage();
          } else {
              // Load existing messages (mock)
              hideWelcomeMessage();
              
              const mockMessages = [
                  {
                      id: 'msg_1',
                      text: 'Hello! How can I help you today?',
                      sender: 'bot',
                      timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString()
                  },
                  {
                      id: 'msg_2',
                      text: 'I need help with project planning.',
                      sender: 'user',
                      timestamp: new Date(Date.now() - 58 * 60 * 1000).toISOString()
                  },
                  {
                      id: 'msg_3',
                      text: 'I\'d be happy to help you with project planning! Let me know what specific aspects you\'d like to focus on.',
                      sender: 'bot',
                      timestamp: new Date(Date.now() - 55 * 60 * 1000).toISOString()
                  }
              ];
              
              // Add messages to UI
              mockMessages.forEach(msg => {
                  addMessage(msg.text, msg.sender, msg.timestamp);
              });
          }
          
      } catch (error) {
          console.error('Error loading chat messages:', error);
          showError('Failed to load chat messages');
      }
  }
  
  /**
   * Initialize chat service - WebSocket only
   */
  async function initializeChat() {
      if (!window.AAAI_CONFIG.ENABLE_WEBSOCKETS) {
          console.error('❌ WebSockets are required for this application');
          showError('WebSocket service is required but disabled in config.');
          return;
      }
      
      if (!window.ChatService) {
          console.error('❌ ChatService not available');
          updateConnectionStatus('disconnected');
          showError('WebSocket service unavailable.');
          return;
      }
      
      try {
          console.log('🔌 Initializing WebSocket-Only ChatService...');
          
          chatService = ChatService.init(AuthService, {
              debug: window.AAAI_CONFIG.ENABLE_DEBUG,
              reconnectInterval: 3000,
              maxReconnectAttempts: 5,
              heartbeatInterval: 60000,
              connectionTimeout: 15000
          });
          
          chatService.onMessage(handleIncomingMessage);
          chatService.onStatusChange(handleConnectionStatusChange);
          chatService.onError(handleChatError);
          
          console.log('📡 Attempting WebSocket connection...');
          await chatService.connect();
          console.log('✅ WebSocket connected successfully');
          
      } catch (error) {
          console.error('❌ Failed to connect WebSocket:', error);
          updateConnectionStatus('disconnected');
          showError(`WebSocket connection failed: ${error.message}. Please try again later.`);
      }
  }
  
  /**
   * Setup all event listeners
   */
  function setupEventListeners() {
      // Sidebar collapse/expand
      elements.sidebarCollapseBtn?.addEventListener('click', toggleSidebar);
      
      // New chat button
      elements.newChatBtn?.addEventListener('click', createNewChat);
      
      // Back button
      elements.backBtn?.addEventListener('click', () => {
          window.location.href = 'project.html';
      });
      
      // Send button and message input
      elements.sendMessageBtn?.addEventListener('click', sendMessage);
      elements.messageInput?.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
          }
      });
      
      // Auto-resize message input
      elements.messageInput?.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = Math.min(this.scrollHeight, 120) + 'px';
      });
      
      // Reconnect button
      elements.reconnectBtn?.addEventListener('click', async () => {
          console.log('🔄 Manual reconnect requested');
          elements.connectionError.style.display = 'none';
          
          if (chatService) {
              try {
                  showStatusIndicator('reconnecting', '🔄 Reconnecting...');
                  await chatService.forceReconnect();
                  console.log('✅ Manual reconnect successful');
              } catch (error) {
                  console.error('❌ Manual reconnect failed:', error);
                  showError('Reconnection failed. Please refresh.');
              }
          } else {
              await initializeChat();
          }
      });
      
      // Page visibility handling
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && 
              AuthService.isAuthenticated() && 
              chatService) {
              
              const status = chatService.getStatus();
              if (!status.connected && !status.connecting) {
                  console.log('🔄 Attempting reconnect on page focus');
                  setTimeout(() => {
                      chatService.connect().catch(console.error);
                  }, 1000);
              }
          }
      });
      
      // Proper cleanup on page unload
      window.addEventListener('beforeunload', () => {
          if (chatService) {
              chatService.disconnect();
          }
      });
  }
  
  /**
   * Toggle sidebar collapse/expand
   */
  function toggleSidebar() {
      sidebarCollapsed = !sidebarCollapsed;
      
      if (sidebarCollapsed) {
          elements.chatSidebar.classList.add('collapsed');
          elements.chatContainer.classList.add('sidebar-collapsed');
          elements.collapseIcon.name = 'chevron-forward-outline';
      } else {
          elements.chatSidebar.classList.remove('collapsed');
          elements.chatContainer.classList.remove('sidebar-collapsed');
          elements.collapseIcon.name = 'chevron-back-outline';
      }
  }
  
  /**
   * Send a message in the current chat - WebSocket only
   */
  async function sendMessage() {
      const text = elements.messageInput.value.trim();
      if (!text || elements.sendMessageBtn.disabled) {
          return;
      }
      
      if (!currentChat) {
          showError('No chat selected');
          return;
      }
      
      console.log('📤 Sending message to chat:', currentChat.id);
      
      // Clear input and disable send button
      elements.messageInput.value = '';
      elements.messageInput.style.height = 'auto';
      elements.sendMessageBtn.disabled = true;
      
      // Hide welcome message
      hideWelcomeMessage();
      
      // Add user message to UI
      const userMsg = addMessage(text, 'user');
      
      // Update chat in list
      updateChatAfterMessage(currentChat.id, text);
      
      try {
          // Send via WebSocket
          console.log('📡 Sending via WebSocket');
          await chatService.sendMessage(text);
          showTypingIndicator();
      } catch (error) {
          console.error('❌ Failed to send message:', error);
          
          if (userMsg) {
              userMsg.remove();
          }
          
          elements.messageInput.value = text;
          showError(`Failed to send message: ${error.message}`);
      } finally {
          elements.sendMessageBtn.disabled = false;
          elements.messageInput.focus();
      }
  }
  
  /**
   * Handle incoming WebSocket messages
   */
  function handleIncomingMessage(data) {
      console.log('📨 Received message:', data.type);
      
      switch (data.type) {
          case 'session_established':
              console.log('🎯 Session established:', data.session_id);
              showStatusIndicator('connected', '✅ Connected');
              hideTypingIndicator();
              break;
              
          case 'message_queued':
              console.log('📬 Message queued:', data.message_id);
              showStatusIndicator('connected', '📬 Message queued');
              
              setTimeout(() => {
                  const typing = document.querySelector('.typing-indicator');
                  if (typing) {
                      typing.innerHTML = '<span>Processing your message...</span>';
                  }
              }, 500);
              break;
              
          case 'message':
              hideTypingIndicator();
              
              if (data.bot_message) {
                  addMessage(
                      data.bot_message.text,
                      'bot',
                      data.bot_message.timestamp,
                      data.bot_message.components
                  );
              } else if (data.text) {
                  addMessage(data.text, 'bot', data.timestamp, data.components);
              }
              
              elements.sendMessageBtn.disabled = false;
              break;
              
          case 'error':
              console.error('❌ Chat error:', data.message);
              hideTypingIndicator();
              addMessage(data.message || 'An error occurred', 'bot');
              elements.sendMessageBtn.disabled = false;
              break;
              
          default:
              console.log('📨 Unknown message type:', data.type, data);
              break;
      }
  }
  
  /**
   * Handle connection status changes
   */
  function handleConnectionStatusChange(status, fullStatus) {
      console.log('📊 Connection status changed:', status);
      updateConnectionStatus(status);
      
      switch (status) {
          case 'connected':
              showStatusIndicator('connected', '✅ WebSocket Connected');
              elements.connectionError.style.display = 'none';
              isConnecting = false;
              processMessageQueue();
              break;
              
          case 'connecting':
              showStatusIndicator('connecting', '⚡ Connecting...');
              isConnecting = true;
              break;
              
          case 'reconnecting':
              showStatusIndicator('reconnecting', `🔄 Reconnecting... (${fullStatus.reconnectAttempts})`);
              isConnecting = true;
              break;
              
          case 'disconnected':
              showStatusIndicator('disconnected', '❌ Disconnected');
              isConnecting = false;
              
              if (fullStatus.reconnectAttempts > 0) {
                  elements.connectionError.style.display = 'block';
              }
              break;
      }
  }
  
  /**
   * Handle chat errors
   */
  function handleChatError(error) {
      console.error('❌ Chat error:', error);
      
      switch (error.type) {
          case 'auth_failed':
              showError('Authentication failed. Please login again.');
              setTimeout(() => {
                  if (confirm('Session expired. Refresh page to login again?')) {
                      window.location.reload();
                  }
              }, 3000);
              break;
              
          case 'max_reconnect_attempts':
              showError('Unable to reconnect to chat server. Please refresh the page.');
              elements.connectionError.style.display = 'block';
              break;
              
          default:
              if (error.requiresLogin || (error.message && error.message.includes('expired'))) {
                  showError('Session expired. Please refresh.');
                  setTimeout(() => {
                      if (confirm('Session expired. Refresh page?')) {
                          window.location.reload();
                      }
                  }, 3000);
              } else {
                  showError(`Chat error: ${error.message || 'Unknown error'}`);
              }
              break;
      }
  }
  
  // UI Helper Functions
  
  function updateChatHeader(chat) {
      elements.chatTitle.textContent = chat.name;
      elements.chatSubtitle.textContent = 
          chat.message_count > 0 
              ? `${chat.message_count} messages`
              : 'Start your conversation';
  }
  
  function updateChatListSelection(selectedChatId) {
      document.querySelectorAll('.chat-item').forEach(item => {
          item.classList.toggle('active', item.dataset.chatId === selectedChatId);
      });
  }
  
  function updateChatAfterMessage(chatId, lastMessage) {
      const chat = chats.find(c => c.id === chatId);
      if (chat) {
          chat.message_count++;
          chat.last_message_preview = lastMessage.substring(0, 50) + (lastMessage.length > 50 ? '...' : '');
          chat.updated_at = new Date().toISOString();
          renderChatList();
          updateChatListSelection(chatId);
      }
  }
  
  function clearChatBody() {
      elements.chatBody.innerHTML = '';
  }
  
  function showWelcomeMessage() {
      elements.welcomeMessage.style.display = 'block';
  }
  
  function hideWelcomeMessage() {
      elements.welcomeMessage.style.display = 'none';
  }
  
  function showChatListLoading(show) {
      elements.loadingChats.style.display = show ? 'block' : 'none';
  }
  
  function showChatListError() {
      elements.chatList.innerHTML = `
          <div class="empty-chat-list">
              <ion-icon name="warning-outline" style="color: #e74c3c;"></ion-icon>
              <p>Failed to load chats.<br>Please refresh.</p>
          </div>
      `;
  }
  
  function addMessage(text, type, timestamp = null, components = null) {
      hideWelcomeMessage();
      
      const msg = document.createElement('div');
      msg.className = type === 'user' ? 'message message-user' : 
                    type === 'system' ? 'message message-system' : 'message message-bot';
      
      const textDiv = document.createElement('div');
      textDiv.textContent = text;
      msg.appendChild(textDiv);
      
      const timeDiv = document.createElement('div');
      timeDiv.className = 'message-timestamp';
      const date = timestamp ? new Date(timestamp) : new Date();
      timeDiv.textContent = date.toLocaleTimeString([], { 
          hour: '2-digit', 
          minute: '2-digit' 
      });
      msg.appendChild(timeDiv);
      
      if (components && uiRenderer) {
          const container = document.createElement('div');
          container.className = 'chat-components-container';
          components.forEach(comp => {
              try {
                  uiRenderer.renderComponent(comp, container);
              } catch (e) {
                  console.error('Component render error:', e);
              }
          });
          msg.appendChild(container);
      }
      
      elements.chatBody.appendChild(msg);
      elements.chatBody.scrollTop = elements.chatBody.scrollHeight;
      
      return msg;
  }
  
  function showTypingIndicator() {
      hideTypingIndicator();
      
      const typing = document.createElement('div');
      typing.className = 'typing-indicator';
      typing.innerHTML = `
          <span class="typing-dot"></span>
          <span class="typing-dot"></span>
          <span class="typing-dot"></span>
      `;
      
      elements.chatBody.appendChild(typing);
      elements.chatBody.scrollTop = elements.chatBody.scrollHeight;
      
      return typing;
  }
  
  function hideTypingIndicator() {
      const existing = document.querySelector('.typing-indicator');
      if (existing) {
          existing.remove();
      }
  }
  
  function updateConnectionStatus(status) {
      if (!elements.connectionDot || !elements.connectionText) return;
      
      elements.connectionDot.className = 'connection-dot';
      
      switch (status) {
          case 'connected':
              elements.connectionDot.classList.add('connected');
              elements.connectionText.textContent = 'WebSocket';
              break;
          case 'connecting':
          case 'reconnecting':
              elements.connectionDot.classList.add('connecting');
              elements.connectionText.textContent = 
                  status === 'connecting' ? 'Connecting...' : 'Reconnecting...';
              break;
          default:
              elements.connectionText.textContent = 'Disconnected';
              break;
      }
  }
  
  function showStatusIndicator(status, message) {
      [elements.connectedStatus, elements.disconnectedStatus, elements.reconnectingStatus]
          .forEach(el => {
              if (el) el.classList.remove('visible');
          });
      
      let indicator = null;
      switch (status) {
          case 'connected':
              indicator = elements.connectedStatus;
              break;
          case 'disconnected':
              indicator = elements.disconnectedStatus;
              break;
          case 'connecting':
          case 'reconnecting':
              indicator = elements.reconnectingStatus;
              break;
      }
      
      if (indicator) {
          indicator.textContent = message;
          indicator.classList.add('visible');
          
          if (status === 'connected') {
              setTimeout(() => {
                  indicator.classList.remove('visible');
              }, 3000);
          }
      }
  }
  
  function showError(message, duration = 5000) {
      console.error('🚨 Error:', message);
      
      const error = document.createElement('div');
      error.style.cssText = `
          position: fixed;
          top: 120px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
          color: white;
          padding: 15px 25px;
          border-radius: 10px;
          z-index: 10000;
          font-weight: 500;
          box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
          max-width: 400px;
          text-align: center;
      `;
      error.textContent = message;
      document.body.appendChild(error);
      
      setTimeout(() => error.remove(), duration);
  }
  
  function processMessageQueue() {
      if (messageQueue.length === 0) return;
      
      console.log(`📤 Processing ${messageQueue.length} queued messages`);
      
      const messages = [...messageQueue];
      messageQueue = [];
      
      messages.forEach(async (msg) => {
          try {
              await chatService.sendMessage(msg.text);
          } catch (error) {
              console.error('❌ Failed to send queued message:', error);
              messageQueue.push(msg);
          }
      });
  }
  
  function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
  }
  
  function getProjectId() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
  }
  
  function getChatIdFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('chat');
  }
  
  function redirectToLogin(reason) {
      console.log('Redirecting to login:', reason);
      window.location.href = 'login.html';
  }
  
  function redirectToProjects() {
      console.log('Redirecting to projects');
      window.location.href = 'project.html';
  }
  
  // Global functions
  window.sendSuggestion = function(text) {
      if (elements.messageInput) {
          elements.messageInput.value = text;
          sendMessage();
      }
  };
  
  window.selectChat = selectChat;
  
  window.showChatMenu = function(chatId, event) {
      // TODO: Implement chat context menu
      console.log('Show chat menu for:', chatId);
  };
  
  // Debug functions
  window.ChatDebug = {
      getStatus: () => chatService ? chatService.getStatus() : null,
      getChats: () => chats,
      getCurrentChat: () => currentChat,
      getCurrentProject: () => currentProject,
      createNewChat: createNewChat,
      selectChat: selectChat,
      toggleSidebar: toggleSidebar,
      reinitialize: initializeChat
  };
  
  console.log('🔍 Debug functions available in window.ChatDebug');
  
  // Start the app
  initializeApp();
});